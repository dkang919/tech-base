<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boid Flocking Aquarium</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0d1b2a; /* 심해 느낌의 배경색 */
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="boidCanvas"></canvas>

<script>
    const canvas = document.getElementById('boidCanvas');
    const ctx = canvas.getContext('2d');

    // 캔버스 크기 설정
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    // 마우스 위치 추적
    let mouse = { x: null, y: null };

    window.addEventListener('mousemove', function(e) {
        mouse.x = e.x;
        mouse.y = e.y;
    });
    
    // 마우스가 화면 밖으로 나가면 효과 해제
    window.addEventListener('mouseout', function() {
        mouse.x = null;
        mouse.y = null;
    });

    window.addEventListener('resize', function() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    });

    // --- 설정값 (Parameters) ---
    // 이 값들을 조절하여 물고기의 움직임 성격을 바꿉니다.
    const CONFIG = {
        count: 200,           // 물고기 마릿수
        visualRange: 100,     // 인식 반경 (친구를 찾는 거리)
        speedLimit: 1,        // 최대 속도
        separationFactor: 0.05, // 서로 밀어내는 힘 (충돌 방지)
        alignmentFactor: 0.005, // 친구들과 같은 방향으로 가려는 힘
        cohesionFactor: 0.005,  // 친구들의 중심으로 모이려는 힘
        mouseRepelDist: 150,    // 마우스 회피 거리
        mouseRepelForce: 0.05,  // 마우스 회피 힘
    };

    class Boid {
        constructor() {
            this.x = Math.random() * width;
            this.y = Math.random() * height;
            // 랜덤한 초기 속도 (-2 ~ 2)
            this.dx = (Math.random() - 0.5) * 4; 
            this.dy = (Math.random() - 0.5) * 4;
        }

        update(boids) {
            // 1. 군집 행동 계산 (응집, 정렬, 분리)
            let separationX = 0, separationY = 0;
            let alignmentX = 0, alignmentY = 0;
            let cohesionX = 0, cohesionY = 0;
            let neighbors = 0;

            let centerX = 0, centerY = 0; // 응집 계산용

            for (let other of boids) {
                if (other === this) continue;

                // 거리 계산
                let dist = Math.hypot(this.x - other.x, this.y - other.y);

                if (dist < CONFIG.visualRange) {
                    // Separation (분리): 너무 가까우면 반대 방향으로 힘을 받음
                    if (dist < 20) { 
                        separationX += this.x - other.x;
                        separationY += this.y - other.y;
                    }

                    // Alignment (정렬): 이웃의 속도를 합산
                    alignmentX += other.dx;
                    alignmentY += other.dy;

                    // Cohesion (응집): 이웃의 위치를 합산
                    centerX += other.x;
                    centerY += other.y;

                    neighbors++;
                }
            }

            if (neighbors > 0) {
                // Alignment 평균 및 적용
                alignmentX /= neighbors;
                alignmentY /= neighbors;
                this.dx += (alignmentX - this.dx) * CONFIG.alignmentFactor;
                this.dy += (alignmentY - this.dy) * CONFIG.alignmentFactor;

                // Cohesion 평균 및 중심점으로의 벡터 계산
                centerX /= neighbors;
                centerY /= neighbors;
                this.dx += (centerX - this.x) * CONFIG.cohesionFactor;
                this.dy += (centerY - this.y) * CONFIG.cohesionFactor;
            }

            // Separation 적용
            this.dx += separationX * CONFIG.separationFactor;
            this.dy += separationY * CONFIG.separationFactor;

            // 2. 마우스 회피 (Repulsion)
            if (mouse.x !== null) {
                let distMouse = Math.hypot(this.x - mouse.x, this.y - mouse.y);
                if (distMouse < CONFIG.mouseRepelDist) {
                    let repelDx = this.x - mouse.x;
                    let repelDy = this.y - mouse.y;
                    this.dx += repelDx * CONFIG.mouseRepelForce;
                    this.dy += repelDy * CONFIG.mouseRepelForce;
                }
            }

            // 3. 속도 제한 (너무 빨라지지 않게)
            let speed = Math.hypot(this.dx, this.dy);
            if (speed > CONFIG.speedLimit) {
                this.dx = (this.dx / speed) * CONFIG.speedLimit;
                this.dy = (this.dy / speed) * CONFIG.speedLimit;
            }

            // 4. 위치 업데이트
            this.x += this.dx;
            this.y += this.dy;

            // 5. 화면 가장자리 처리 (Screen Wrapping)
            // 오른쪽 끝으로 나가면 왼쪽에서 등장 (반대도 동일)
            if (this.x > width) this.x = 0;
            if (this.x < 0) this.x = width;
            if (this.y > height) this.y = 0;
            if (this.y < 0) this.y = height;
        }

        draw() {
            // 이동 방향(각도) 계산
            let angle = Math.atan2(this.dy, this.dx);

            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(angle);

            // 물고기(화살표) 그리기
            ctx.beginPath();
            ctx.moveTo(10, 0);   // 머리
            ctx.lineTo(-5, 5);   // 왼쪽 날개
            ctx.lineTo(-5, -5);  // 오른쪽 날개
            ctx.lineTo(10, 0);   // 다시 머리로
            
            // 색상 및 스타일
            ctx.fillStyle = `rgba(100, 200, 255, 0.8)`;
            ctx.fill();
            ctx.restore();
        }
    }

    // 보이드 생성
    const boids = [];
    for (let i = 0; i < CONFIG.count; i++) {
        boids.push(new Boid());
    }

    // 애니메이션 루프
    function animate() {
        ctx.clearRect(0, 0, width, height); // 화면 지우기
        
        for (let boid of boids) {
            boid.update(boids);
            boid.draw();
        }

        requestAnimationFrame(animate);
    }

    animate();
</script>
</body>
</html>